题目描述

输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。


这里可以提供三种思路：


思路一：

先判断整数二进制表示中最右边以为是不是1。接着把输入的整数右移一位，此时原来处于从右边暑期的第二位被移到最有边了，再判断是不是1，
这样每次移动一位，直到整个整数变为0为止。现在的问题变成了怎么判断一个整数的最右边是不是1，方法是只要把整数和1做与运算看结果是不是0就知道了。
1除了最右边的一位之外所有位都是0。如果一个整数与1做与运算的结果是1，表示该整数最右边一位是1，否则是0。代码如下：
int NumberOf1(int n)
{
    int count = 0;
    while(n != 0)
    {
        if(n & 1)
            count++;
        n = n >> 1;//把整数右移一位和把整数除以2在数学上是等价的，但除法的效率比移位运算要低得多，在实际编程中应尽可能地使用移位运算代替乘除法
    }
    return count;
}
上面的方法是编译不通过的：可能会陷入死循环。如果输入的是一个负数，比如0x80000000，运行时会是什么情况呢？
把负数0x80000000右移一位，并不是简单地把最高位的1移到第二位变成0x40000000，而是0xC0000000.这是因为移位前是个负数，
仍然要保证移位后是个负数，因此移位后的最高位会设为1，如果一直做右移运算，最终结果就会变成0xFFFFFFFF而陷入死循环。



思路二：


为了避免死循环，我们不使数字n右移。首先把n和1做与运算，判断n的最低位是不是1，接着把1左移一位得到2，再和n做与运算，
就能判断n的次低位是不是1，重复上述步骤，每次都能判断n的其中一位是不是1.

代码如下：
int NumberOf1(int n)
{
    int count = 0;
    unsigned int flag = 1;
    while(n != 0)
    {
        if(n & flag)
            count++;
        flag = flag << 1;
    }
    return count;
}
此方法循环的次数等于整数二进制的位数，32 为的整数需要循环32次，但并不是每个整数中1的个数都有32个，因此，此解法并不算最优。

思路三（最优）：

在分析这种算法之前，我们分析把一个数减1的情况，如果一个整数不等于0，那么该整数的二进制表示中至少有一位是1。
先假设这个数的最右边一位是1，减去1时，最后一位变成0而其他所有位都保持不变。也就是最后一位相当于取反操作，由1变成了0,。
接下来假设最后一位不是1而是0的情况。如果该整数的二进制表示中最右边的1位于第m位，那么减去1时，第m位由1变成0，而第m位之后的所有0变成1，整数中第m位之前的所有位都保持不变。
举个例子能证明：一个二进制数1100，它的第二位是从最右边数起的一个1.减去1后，第二位变成0，它最后的两位0变成1，而前面的1保持不变，因此得到的结果是1011。
在前面两种情况中，我们发现把一个整数减去1，都是把最右边的1变成0。如果它的右边还有0的话，所有的0变成1，而它右边所有位都保持不变。
然后我们把一个整数和它减去1的结果做与运算，相当于把它最右边的1变成0.仍然以1100为例，它减去1的结果是1011,。我们再把1100和1011做与运算，得到的结果是1000.我们把1100最右边的1变成了，结果刚好就是1000.


综上所述：把一个整数减去1，再和原整数做与运算，会把该整数最右边的一个1变成0,。那么一个整数的二进制表示中有多少个1，就可以进行多少次这样的操作。代码如下：
int NumberOf1(int n)
{
    int count = 0;
    
    while(n != 0)
    {
        count++;
        n = n & (n-1);
    }
    return count;
}